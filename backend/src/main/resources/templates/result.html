<!DOCTYPE html>

<html xmlns:th="http://www.thymeleaf.org">
  <body>
    <h1>Result</h1>
    <p>GPX uploaded successfully</p>
    <p>Name: <span th:text="${gpx.name}" /></p>
    <p>Description: <span th:text="${gpx.description}" /></p>
    <p>Elevation Gain: <span th:text="${gpx.elevationGain}" /> m</p>
    <p>Elevation Loss: <span th:text="${gpx.elevationLoss}" /> m</p>
    <p>Distance: <span th:text="${gpx.distance}" /> m</p>
    <p>Hills:</p>
    <ul>
      <li th:each="hill : ${gpx.hills}" th:text="${hill.gain + ' m'}"></li>
    </ul>
    <div id="threejs-container" style="width: 600px; height: 400px"></div>
    <script th:inline="javascript">
      /*<![CDATA[*/
      const gpx = [[${gpx}]];
      console.log(gpx);
      /*]]>*/
    </script>
    <script type="module">
      import * as THREE from "./packages/threeJS/three.module.js";
      import { OrbitControls } from "./packages/threeJS/OrbitControls.js";
      // import { FlyControls } from "./packages/threeJS/FlyControls.js";

      // Hooray for some dude on YouTube
      // https://www.youtube.com/watch?v=nwiaqLGAyjo&t=12s&ab_channel=WaelYasmina

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 600 / 400, 0.1, 100000);
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(600, 400);
      document
        .getElementById("threejs-container")
        .appendChild(renderer.domElement);

      // Debug points
      const points = gpx.trackPointsCartesian.map(
        (p) => new THREE.Vector3(p.x, p.y, p.z)
      );

      // Make a cube at the start, to indicate the start of the track
      const startCubeGeometry = new THREE.BoxGeometry(200, 200, 200);
      const startCubeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
      });
      const startCube = new THREE.Mesh(startCubeGeometry, startCubeMaterial);
      startCube.position.copy(points[0]);
      scene.add(startCube);

      // Make a cube at the end, to indicate the end of the track
      const endCubeGeometry = new THREE.BoxGeometry(200, 200, 200);
      const endCubeMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
      });
      const endCube = new THREE.Mesh(endCubeGeometry, endCubeMaterial);
      endCube.position.copy(points[points.length - 1]);
      scene.add(endCube);

      // Calculate bounding box
      const box = new THREE.Box3().setFromPoints(points);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      // Position camera to see the whole model
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

      // Create geometry
      const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
      const pathMesh = new THREE.Line(pathGeometry, pathMaterial);
      scene.add(pathMesh);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      controls.enablePan = true;
      controls.enableRotate = true;
      controls.enableKeys = true;

      // const midPoint = points.at(points.length / 2);

      // Add some padding
      cameraZ *= 1.5;

      camera.position.set(center.x, center.y, center.z + cameraZ);
      camera.lookAt(center);
      controls.target.copy(center);

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);

        // console.log("Camera position:", camera.position);
        // console.log("Camera target:", camera.target);

        // x: -6260.536939427118;
        // y: -12549.168721362097;
        // z: 5781.385933826956;
      }
      animate();
    </script>
  </body>
</html>
